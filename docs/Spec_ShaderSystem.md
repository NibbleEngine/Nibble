## Nibble Shader System

One of the main goals of Nibble since its meant to be a game engine, is live shader editing. This is a hell of a task by itself, and requires a delicate design of all the involved components so that this procedure works without any issues and catastrophic bugs. 

### 1. Design

#### 1.1 Shader Source Files

Shader source files are loaded from disk into `GLSLShaderSource` objects. During initialization file watchers are set for each source file. Each shader source object has a `NbShaderType` attribute that can be used to differentiate between dynamic and static source objects. Dynamic sources correspond to externally loaded source files, while static sources can be used to store static text.

Shader source files have two processing levels: a) Processing and b) Resolution. 

During processing, the actual source text is parsed, directives such as `#include` are recognized. Essentially the source text is broken down to static text parts which get stored into static `GLSLShaderSource` objects and dynamic text parts which hold referce to dynamic `GLSLShaderSource` objects. In the case of dynamic text parts, the engine makes sure to first load and store the source file prior to referencing it.

During resolution, the final source code of the shader source is assembled by carefully combining static and dynamic text parts in the correct order.

When the source file are modified, the corresponding `GLSLShaderSource` object is re-processed and re-resolved automatically. In addition, the `GLSLShaderSource` class includes an `IsUpdated` event delegate that is invoked right after the re-resolution of the object.

#### 1.2 Shader Configurations

`GLSLShaderConfig` objects are introduced to group shader sources and essentially make shader management more robust. The main idea is that one may have exactly the same source files, but with different preprocessor flags. This means that two different shaders should be generated. Therefore, `GLSLShaderConfig` objects are used to store references to `GLSLShaderSource` objects but also extra preprocessor flags that may need to be introduced.

The `GLSLShaderConfig` contains placeholders for the 5 possible shaders that can be attached to a shader: a vertex shader, a fragment shader, a geometry shader, a tesselation evaluation shader and a tesselation control shader. During the initialization of a `GLSLShaderConfig` object, shader source objects for at least the vertex and the fragment shader should be provided, along with some other configuration options.

When a `GLSLShaderSource` object is attached to a `GLSLShaderConfig` object via the call to the `AddSource` method, the `GLSLShaderConfig` object subscribes its `OnShaderSourceUpdate` callback to the `IsUpdated` event of the `GLSLShaderSource` object. This allows the `GLSLShaderConfig` to take notice of the source updates and act.

#### 1.3 Materials

`MeshMaterial` is the material class in Nibble. Along with other material attributes the `MeshMaterial` class holds a list of material flags that can also be used again as preprocessor flags to enable specific parts of the shader source file (possibly in an ubershader setting). Another attribute is a reference to the corresponding `NbShader` object that should be used for rendering the material. The `MeshMaterial` class also includes an `IsUpdated` event delegate that is invoked when material attributes (such as the material flags) are updated. 

#### 1.4 Shaders

`NbShader` objects are the result of the shader compilation process that is executed by the `GraphicsAPI`. Such objects hold among other attributes, the actual shader program generated during compiation, a unique hash that is generated by the combination of all preprocessor flags as well as the shader source files used for compilation, a list of extra directives that may be provided via a material and also a reference fo the `GLSLShaderConfig` object that was used to derive the shader sources. `NbShader` objects also keep track of a reference counter, which holds the number of objects that hold references to a particular shader. This is not used atm, but the idea is to be able to identify obsolete shaders and clean them up.


### 2. Shader (Re-)Compilation Workflow


There are two possible ways that a shader is compiled. a) It can be compiled direcly using a `NbShader` or b) using a  `GLSLShaderConfig` object and a list of directives. In the first case directives stored directly in the `NbShader` object will be used during compilation. After shader compilation the shader's `OnUpdate` method is subscribed to the `IsUpdated` event of the `GLSLShaderConfig` object that was used for the shader compilation. This will connect the shader to the corresponding configuration, which allows an automatic recompilation trigger when the configuration is updated. If the shader is meant to be attached to a material, than in this case the shader should be attached to the shader using the `AttachShader` method. In addition, the material is subscribed to the `IsUpdated` event of the shader.  This serves the purpose of updating material uniforms and sampler information once the shader has been updated. For now the `IsUpdated` event of the shader is invoked right after a successful shader compilation.

When a material is updated, for example when new flags are introduced, a new shader is always generated with the previous shader's configuration and the directives as derived from the updated material settings. Since the shader is not directly compiled (it is will be compiled at the start of the NEXT frame), the material is unsubscribed from the old shader `IsUpdated` event and is subscribed to the new shader's `IsUpdated` event. The old shader reference is not directly removed, so that the material information for the current frame remains consistent. Once the new shader is compiled successfully, the `OnShaderUpdate` method of the `MeshMaterial` is called via the `IsUpdated` event of the new shader. Within this method, if the new shader contains consistent information it replaces the old shader (shader reference counters are properly updated). Finally if the old shader has no other references, it is disposed.


### Classes

- [GLSLShaderConfig](#glslshaderconfig)
- [GLSLShaderSource](#glslshadersource)
- [NbShader](#nbshader)
- [MeshMaterial](#meshmaterial)



#### GLSLShaderSource


#### GLSLShaderConfig


#### NbShader


#### MeshMaterial









### Support or Contact
For questions, suggestions or inquiries please mail me at <gregkwaste@gmail.com>
