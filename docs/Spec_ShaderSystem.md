## Nibble Shader System

One of the main goals of Nibble since its meant to be a game engine, is live shader editing. This is a hell of a task by itself, and requires a delicate design of all the involved components so that this procedure works without any issues and catastrophic bugs. 

### 1. Design

#### 1.1 Shader Source Files

Shader source files are loaded from disk into `GLSLShaderSource` objects. During initialization file watchers are set for each source file. Each shader source object has a `NbShaderType` attribute that can be used to differentiate between dynamic and static source objects. Dynamic sources correspond to externally loaded source files, while static sources can be used to store static text.

Shader source files have two processing levels: a) Processing and b) Resolution. 

During processing, the actual source text is parsed, directives such as `#include` are recognized. Essentially the source text is broken down to static text parts which get stored into static `GLSLShaderSource` objects and dynamic text parts which hold referce to dynamic `GLSLShaderSource` objects. In the case of dynamic text parts, the engine makes sure to first load and store the source file prior to referencing it.

During resolution, the final source code of the shader source is assembled by carefully combining static and dynamic text parts in the correct order.

When the source file are modified, the corresponding `GLSLShaderSource` object is re-processed and re-resolved automatically. In addition, the `GLSLShaderSource` class includes an `IsUpdated` event delegate that is invoked right after the re-resolution of the object.

#### 1.2 Shader Configurations

`GLSLShaderConfig` objects are introduced to group shader sources and essentially make shader management more robust. The main idea is that one may have exactly the same source files, but with different preprocessor flags. This means that two different shaders should be generated. Therefore, `GLSLShaderConfig` objects are used to store references to `GLSLShaderSource` objects but also extra preprocessor flags that may need to be introduced.

The `GLSLShaderConfig` contains placeholders for the 5 possible shaders that can be attached to a shader: a vertex shader, a fragment shader, a geometry shader, a tesselation evaluation shader and a tesselation control shader. During the initialization of a `GLSLShaderConfig` object, shader source objects for at least the vertex and the fragment shader should be provided, along with some other configuration options.

When a `GLSLShaderSource` object is attached to a `GLSLShaderConfig` object via the call to the `AddSource` method, the `GLSLShaderConfig` object subscribes its `OnShaderSourceUpdate` callback to the `IsUpdated` event of the `GLSLShaderSource` object. This allows the `GLSLShaderConfig` to take notice of the source updates and act.

#### 1.3 Materials

`MeshMaterial` is the material class in Nibble. Along with other material attributes the `MeshMaterial` class holds a list of material flags that can also be used again as preprocessor flags to enable specific parts of the shader source file (possibly in an ubershader setting). Another attribute is a reference to the corresponding `NbShader` object that should be used for rendering the material. The `MeshMaterial` class also includes an `IsUpdated` event delegate that is invoked when material attributes (such as the material flags) are updated. 

#### 1.4 Shaders

`NbShader` objects are the result of the shader compilation process that is executed by the `GraphicsAPI`. Such objects hold among other attributes, the actual shader program generated during compiation, a unique hash that is generated by the combination of all preprocessor flags as well as the shader source files used for compilation, a list of extra directives that may be provided via a material and also a reference fo the `GLSLShaderConfig` object that was used to derive the shader sources. `NbShader` objects also keep track of a reference counter, which holds the number of objects that hold references to a particular shader. This is not used atm, but the idea is to be able to identify obsolete shaders and clean them up.


### 2. Shader (Re-)Compilation Workflow


There are two possible ways that a shader is compiled. a) It can be compiled direcly using a `GLSLShaderConfig` object as an input. This assumes that there are no extra directives apart from those included in the `GLSLShaderConfig` object object. After shader compilation the shader's `OnUpdate` method is subscribed to the `IsUpdated` event of the `GLSLShaderConfig` object that was used for the shader compilation. This will connect the shader to the corresponding configuration, which allows an automatic recompilation trigger when the configuration is updated.  b) It can be compiled using both a `GLSLShaderConfig` object as well as a `MeshMaterial` object. The difference in this case is that first the material attributes are passed to the `NbShader` object and therefore they will be used during shader compilation. Second, this time the `NbShader` object will subscribe to the `IsUpdated` events of both the material and the configuration. This allows for the automated trigger of shader compilation in the case of a configuration update, but also trigger the compilation of a new shader object that will be automatically attached to the material when a material update occurs.





### Classes

- [GLSLShaderConfig](#glslshaderconfig)
- [GLSLShaderSource](#glslshadersource)
- [NbShader](#nbshader)
- [MeshMaterial](#meshmaterial)



#### GLSLShaderSource


#### GLSLShaderConfig


#### NbShader


#### MeshMaterial









### Support or Contact
For questions, suggestions or inquiries please mail me at <gregkwaste@gmail.com>
